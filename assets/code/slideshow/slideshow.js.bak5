// Slideshow loader + tool with dark mode support via CSS variables

// Synchronize dark mode from parent <html> to iframe <html>
(function syncDarkModeFromParent() {
  try {
    const iframeHtml = document.documentElement;
    const parentClass = window.parent.document.documentElement.className;
    iframeHtml.className = parentClass;

    // Observe changes to the parent's <html class="...">
    const observer = new MutationObserver(() => {
      iframeHtml.className = window.parent.document.documentElement.className;
    });

    observer.observe(window.parent.document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  } catch (err) {
    console.warn("[Slideshow] Could not sync dark mode:", err);
  }
})();


window.addEventListener("DOMContentLoaded", () => {
  const iframeId = window.frameElement?.id;
  const canvas = document.querySelector("canvas");

  if (!iframeId || !canvas) {
    console.error("[Slideshow] Could not determine iframe ID or canvas element.");
    return;
  }

  const configPath = `external/code/slideshow/${iframeId}-config.json`;

  fetch(configPath)
    .then(res => res.json())
    .then(config => {
      runSlideshow(canvas.id, config);
    })
    .catch(err => console.error("[Slideshow] Config load failed:", err));

});

function runSlideshow(canvasId, config) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");

  const slides = config.slides;
  const settings = config.settings || {};
  const layout = settings.layout || "horizontal";

  let currentSlide = 0;
  let hoverBack = false;
  let hoverNext = false;
  const buttonWidth = 70;
  const buttonHeight = 26;
  const panelPadding = 6;
  const canvasPadding = 10;
  
  const fontSize = settings.fontSize || 16;
  const fontStyle = settings.fontStyle || "normal";
  const imageCache = {};
  const backButton = { text: "◀ Back", x: 0, y: 0 };
  const nextButton = { text: "Next ▶", x: 0, y: 0 };
  const indicators = { baseRadius: 6, baseSpacing: 20 };

  let touchStartX = null;

  canvas.addEventListener("touchstart", e => {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
    }
  }, { passive: true });

  canvas.addEventListener("touchend", e => {
    if (touchStartX === null) return;
    const touchEndX = e.changedTouches[0].clientX;
    const deltaX = touchEndX - touchStartX;

    const swipeThreshold = 50; // Minimum px to count as a swipe
    if (Math.abs(deltaX) > swipeThreshold) {
      if (deltaX < 0 && currentSlide < slides.length - 1) {
        currentSlide++;
        drawSlide();
      } else if (deltaX > 0 && currentSlide > 0) {
        currentSlide--;
        drawSlide();
      }
    }
    touchStartX = null;
  }, { passive: true });

  function isDarkMode() {
    return document.documentElement.classList.contains("dark-mode");
  }

  preloadImages(slides, () => drawSlide());

  function preloadImages(slides, callback) {
    let loaded = 0;
    for (const slide of slides) {
      const img = new Image();
      img.onload = () => {
        loaded++;
        if (loaded === slides.length) callback();
      };
      img.src = slide.image;
      imageCache[slide.image] = img;
    }
  }

  function drawSlide() {
    const darkModeObserver = new MutationObserver(() => drawSlide());
    darkModeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"]
    });

    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    const dark = isDarkMode();
    const textColor = dark ? "#f2f2f2" : "#0d0d0e";
    const backgroundColor = dark ? "#2c2d29" : "#f0f4f8";
    const buttonColor = dark ? "#66bb6a" : "#4CAF50";
    const hoverColor = dark ? "#81c784" : "#388e3c";
    const borderColor = dark ? "#444" : "#ccc";
    const indicatorInactive = dark ? "#777" : "#ddd";

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const img = imageCache[slides[currentSlide].image];
    if (!img) return;

    if (layout === "horizontal") {
      drawHorizontalLayout(ctx, img, textColor, backgroundColor, buttonColor, hoverColor, borderColor, indicatorInactive);
    } else {
      drawVerticalLayout(ctx, img, textColor, backgroundColor, buttonColor, hoverColor, borderColor, indicatorInactive);
    }
  }

  function drawHorizontalLayout(ctx, img, textColor, backgroundColor, buttonColor, hoverColor, borderColor, indicatorInactive) {

    const controlPanelWidth = 200;
    // ---- Image ----
    // properties
    const imageWidth = canvas.width - controlPanelWidth - canvasPadding * 2;
    const imageHeight = canvas.height - 2 * canvasPadding;
    // draw
    const imgAspect = img.width / img.height;
    const panelAspect = imageWidth / imageHeight;
    let drawWidth = imageWidth, drawHeight = imageHeight;
    if (imgAspect > panelAspect) drawHeight = imageWidth / imgAspect;
    else drawWidth = imageHeight * imgAspect;
    ctx.drawImage(img, canvasPadding, canvasPadding, drawWidth, drawHeight);

    // ---- Control panel ----
    // properties
    const panelX = imageWidth + canvasPadding;
    const panelY = canvasPadding;
    const panelHeight = imageHeight;
    const panelCenterX = panelX + controlPanelWidth / 2;
    // draw
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(panelX, panelY, controlPanelWidth, panelHeight);

    // ---- Separator ----
    drawVerticalSeparator(panelX, panelY, panelHeight, borderColor);

    // ---- Text box ----
    // properties
    const reservedHeight = buttonHeight + canvasPadding + 40;
    // draw
    drawTextBox(
      panelX + canvasPadding,
      panelY + canvasPadding,
      controlPanelWidth - 2 * canvasPadding,
      panelHeight - reservedHeight,
      textColor, backgroundColor, borderColor
    );
    
    // ---- Buttons ----
    // properties
    const totalButtonWidth = 2 * buttonWidth + panelPadding;
    const buttonStartx = panelCenterX - totalButtonWidth / 2;
    const buttonStarty = panelY + panelHeight - buttonHeight - 30;
    // draw
    drawButtons(buttonStartx, buttonStarty, buttonColor, hoverColor);
    
    // ---- Slide indicators ----
    // properties
    const indicatorX = panelX + controlPanelWidth / 2;
    const indicatorTopY = buttonStarty + buttonHeight + canvasPadding;
    const indicatorMaxWidth = controlPanelWidth - 2 * canvasPadding;
    // draw
    drawSlideIndicators(indicatorX, indicatorTopY, indicatorMaxWidth, buttonColor, indicatorInactive, /* centered = */ true);

  }

  function drawVerticalLayout(ctx, img, textColor, backgroundColor, buttonColor, hoverColor, borderColor, indicatorInactive) {

    // ---- Control panel ----
    // properties
    const panelWidth = canvas.width - 2 * canvasPadding;
    const panelHeight = buttonHeight + 3 * panelPadding + 2 * indicators.baseRadius;
    const panelX = canvasPadding;
    const panelY = canvas.height - panelHeight - canvasPadding;
    // draw
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    ctx.strokeStyle = borderColor;
    ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);

    // ---- Image ----
    // properties
    const imgAspect = img.width / img.height;
    const imageHeight = canvas.height - panelHeight - 3 * canvasPadding;
    const imageWidth = imageHeight * imgAspect;
    const imgX = (canvas.width - imageWidth) / 2;
    const imgY = canvasPadding;
    // draw
    ctx.drawImage(img, imgX, imgY, imageWidth, imageHeight);

    // ---- Separator ----
    drawHorizontalSeparator(canvasPadding, imageHeight, canvas.width - 2 * canvasPadding, borderColor);

    // ---- Buttons ----
    // properties
    const totalButtonWidth = 2 * buttonWidth + panelPadding;
    const buttonX = canvas.width - totalButtonWidth - panelPadding - canvasPadding;
    const buttonTopY = panelY + panelPadding;
    // draw
    drawButtons(buttonX, buttonTopY, buttonColor, hoverColor);

    // ---- Slide indicators ----
    // properties
    const indicatorX = buttonX + buttonWidth;
    const indicatorTopY = buttonTopY + buttonHeight + panelPadding;
    const indicatorMaxWidth = totalButtonWidth;
    // draw
    drawSlideIndicators(indicatorX, indicatorTopY, indicatorMaxWidth, buttonColor, indicatorInactive, /* centered = */ true);

    // ---- Text box ----
    // properties
    const textBoxX = panelX + panelPadding;
    const textBoxY = panelY + panelPadding;
    const textBoxHeight = panelHeight - 2 * panelPadding;
    const textBoxWidth = buttonX - panelPadding - textBoxX;
    // draw
    drawTextBox(textBoxX, textBoxY, textBoxWidth, textBoxHeight, textColor, backgroundColor, borderColor);

  }

  function drawVerticalSeparator(x, y, height, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - canvasPadding / 2, y);
    ctx.lineTo(x - canvasPadding / 2, y + height);
    ctx.stroke();
  }

  function drawHorizontalSeparator(x, y, width, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y + 1.5 * canvasPadding);
    ctx.lineTo(x + width, y + 1.5 * canvasPadding);
    ctx.stroke();
  }

  function drawTextBox(x, y, width, height, textColor, backgroundColor, borderColor) {
    const slide = slides[currentSlide];
    const fullText = slide.title + '. ' + slide.text;

    ctx.fillStyle = backgroundColor;
    ctx.fillRect(x, y, width, height);
    ctx.strokeStyle = borderColor;
    ctx.strokeRect(x, y, width, height);

    ctx.fillStyle = textColor;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = fontStyle + ` ${fontSize}px 'Roboto', sans-serif`;

    const lineHeight = 18;
    const maxLines = Math.floor((height - 10) / lineHeight);
    const wrappedLines = wrapText(ctx, fullText, width - 10);
    for (let i = 0; i < Math.min(wrappedLines.length, maxLines); i++) {
      ctx.fillText(wrappedLines[i], x + 5, y + 5 + i * lineHeight);
    }
  }

  function drawButtons(xStart, y, buttonColor, hoverColor) {
    const xBack = xStart;
    const xNext = xBack + buttonWidth + panelPadding;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `${fontSize}px 'Roboto', sans-serif`;
    ctx.shadowColor = "rgba(0,0,0,0.1)";
    ctx.shadowBlur = 4;

    ctx.fillStyle = currentSlide === 0 ? "#888" : (hoverBack ? hoverColor : buttonColor);
    roundedRect(xBack, y, buttonWidth, buttonHeight, 8);
    ctx.fillStyle = "#fff";
    ctx.fillText(backButton.text, xBack + buttonWidth / 2, y + 1.05 * buttonHeight / 2);
  
    ctx.fillStyle = currentSlide === slides.length - 1 ? "#888" : (hoverNext ? hoverColor : buttonColor);
    roundedRect(xNext, y, buttonWidth, buttonHeight, 8);
    ctx.fillStyle = "#fff";
    ctx.fillText(nextButton.text, xNext + buttonWidth / 2, y + 1.05 * buttonHeight / 2);

    ctx.shadowColor = "transparent";

    // Save button coordinates for hover detection
    backButton.x = xBack;
    backButton.y = y;
    nextButton.x = xNext;
    nextButton.y = y;
  }

  function drawSlideIndicators(centerX, topY, maxWidth, buttonColor, inactiveColor, centered = false) {
    const baseRadius = indicators.baseRadius, baseSpacing = indicators.baseSpacing;
    const indicatorWidth = (slides.length - 1) * baseSpacing + 2 * baseRadius + 2 * canvasPadding;
    const scale = indicatorWidth > maxWidth ? maxWidth / indicatorWidth : 1;
    const radius = baseRadius * scale, spacing = baseSpacing * scale;
    const totalWidth = (slides.length - 1) * spacing;
    const startX = centered ? centerX - totalWidth / 2 : centerX;
    const centerY = topY + radius;

    for (let i = 0; i < slides.length; i++) {
      ctx.fillStyle = (i === currentSlide) ? buttonColor : inactiveColor;
      ctx.beginPath();
      ctx.arc(startX + i * spacing, centerY, radius, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  function roundedRect(x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  function wrapText(ctx, text, maxWidth) {
    const lines = [];
    for (const paragraph of text.split("\n")) {
      const words = paragraph.split(" ");
      let line = "";
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + " ";
        if (ctx.measureText(testLine).width > maxWidth && i > 0) {
          lines.push(line.trim());
          line = words[i] + " ";
        } else {
          line = testLine;
        }
      }
      lines.push(line.trim());
    }
    return lines;
  }
  
  canvas.addEventListener("mousemove", e => {
    const { left, top } = canvas.getBoundingClientRect();
    const x = e.clientX - left, y = e.clientY - top;
    const back = backButton;
    const next = nextButton;
    // const { back, next } = getButtonCoordinates();

    hoverBack = x >= back.x && x <= back.x + buttonWidth && y >= back.y && y <= back.y + buttonHeight && currentSlide > 0;
    hoverNext = x >= next.x && x <= next.x + buttonWidth && y >= next.y && y <= next.y + buttonHeight && currentSlide < slides.length - 1;

    canvas.style.cursor = (hoverBack || hoverNext) ? "pointer" : "default";
    drawSlide();
  });

  canvas.addEventListener("click", e => {
    const { left, top } = canvas.getBoundingClientRect();
    // const x = e.clientX - left, y = e.clientY - top;
    // const back = backButton;
    // const next = nextButton;
    // const { back, next } = getButtonCoordinates();

    if (hoverBack && currentSlide > 0) currentSlide--;
    else if (hoverNext && currentSlide < slides.length - 1) currentSlide++;
    drawSlide();
  });

  // function getButtonCoordinates() {
  //   if (layout === "horizontal") {
  //     const imageHeight = canvas.height - 2 * canvasPadding;
  //     const y = canvasPadding + imageHeight - buttonHeight - 30;
  //     const panelX = canvas.width - controlPanelWidth + canvasPadding;
  //     const panelCenter = panelX + (controlPanelWidth - canvasPadding * 2) / 2;
  //     const totalWidth = 2 * buttonWidth + panelPadding;
  //     const xStart = panelCenter - totalWidth / 2;
  //     return {
  //       back: { x: xStart, y },
  //       next: { x: xStart + buttonWidth + panelPadding, y }
  //     };
  //   } else {
  //     const panelY = canvas.height * 0.65 + canvasPadding;
  //     const y = panelY + canvas.height * 0.35 - buttonHeight - 30;
  //     const panelCenter = canvas.width / 2;
  //     return {
  //       back: { x: panelCenter - buttonWidth - panelPadding, y },
  //       next: { x: panelCenter + panelPadding, y }
  //     };
  //   }
  // }
}