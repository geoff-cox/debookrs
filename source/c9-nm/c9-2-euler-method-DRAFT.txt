<section><title> Euler's Method </title>

	<p>
		Euler's method operates on a very intuitive principle: starting from an initial point, the method uses the differential equation itself to take small steps along the direction of the slope given by the equation. At each step, the method calculates the slope of the unknown function at the current point, then moves a small distance in the direction of this slope to find the next point. By repeating this process, Euler's method generates a sequence of points that approximates the true solution curve of the differential equation.
	</p>

	<p>
		In this section, we'll build intuition for the most common kind of numerical method ,  one that approximates the solution to an initial value problem by computing values of <m>y(t)</m> one step at a time. It might feel a little strange at first, but you're not solving the entire equation at once. Instead, you're just walking forward from one point to the next, building a trail of approximate values as you go.
	</p>

	<p>
		To give you an idea of how some of these methods work, imagine you are hiking through the woods in the fog from point <m>A</m> to <m>B</m>. Assuming there exists a best possible path, can you approximate if you only knew the information below?
		<ul marker="square">
			<li>
				<p>
					Your current position.
				</p>
			</li>
			<li>
				<p>
					The direction you should go from your current position.
				</p>
			</li>
		</ul>
	</p>

	<p>
		To make progress from point <m>A</m>, you walk in a direction for some time, then stop, note your current position and recalculate the new direction to walk. You repeat this process until, ideally, you are somewhere near point <m>B</m>.
	</p>

	<p>
		In this analogy, the solution you are trying to approximate is the best possible path from point <m>A</m> to <m>B</m>. The approximation is the collection of current positions (starting with <m>A</m>) you noted when you stopped to update your direction. This systematic process is precisely how some numerical methods work.
	</p>

	<exercise><title> What's the Tradeoff </title>
		<statement>
			<p>
				In the previous analogy, what trade-off do you think exists when approximating the best possible path?
			</p>
		</statement>
		<choices randomize="yes">
			<choice correct="yes">
				<statement>
					The more often you stop to recalculate your position, the more accurate your approximation, but the longer it takes.
				</statement>
				<feedback>
					Correct ,  stopping more often gives you a better approximation, but it also takes more time.
				</feedback>
			</choice>
			<choice>
				<statement>
					The less often you stop, the more accurate your approximation.
				</statement>
				<feedback>
					This is not true ,  stopping less often leads to a less accurate approximation.
				</feedback>
			</choice>
			<choice>
				<statement>
					The more often you stop, the less accurate your approximation.
				</statement>
				<feedback>
					This is not true ,  stopping more often leads to a more accurate approximation.
				</feedback>
			</choice>
			<choice>
				<statement>
					The direction you choose does not affect the accuracy of your approximation.
				</statement>
				<feedback>
					This is not true ,  the direction you choose is crucial for making progress toward the best path.
				</feedback>
			</choice>
		</choices>
	</exercise>

	<paragraphs><title> An Analogy </title>
		<p>
			Imagine you're a tiger hunting prey in a dense forest. You can't see the prey, but you can smell which direction it's in. So you head in that direction for 5 seconds, then stop to sniff the air again and adjust your course. You repeat this process ,  move a bit, check the scent, adjust ,  until you either find your prey or lose the trail.
		</p>

		<p>
			This is the essence of Euler's Method. The tiger's position every 5 seconds is like the numerical solution: a series of approximated locations. The prey's true path is the exact, analytic solution to the differential equation. And the scent? That's the derivative ,  the information that tells you which direction to go next.
		</p>

		<p>
			Just like the tiger, Euler's Method doesn't know the full path in advance. It only knows where it is and which way to head ,  based on the differential equation ,  and it follows that direction one small step at a time.
		</p>
	</paragraphs>

	<paragraphs><title> Stepping Between Two Points </title>
		<p>
			Euler's method works by attempting to follow the graph of the solution, one point at a time. It can't see the solution, but it always knows what direction it would move at any given point. 
		</p>

		<p>	
			As an analogy, imagine you are playing a game where you must walk along a random path blindfolded. You are nudged in the direction of the path and must walk a distance of your choice where you can get another nudge. If the path is straight, you could follow it easily. But if the path curves, you might veer off course between nudges. A similar idea holds for Euler's method, except that it uses the slope of the solution's tangent line to determine the direction to move at each point.
		</p>
	</paragraphs>

	<paragraphs><title> Rule for Moving From One Point to the Next </title>
		<p>
			Starting with the initial condition, Euler's method produces a sequence of points, one-by-one, over some given interval. Therefore, it needs a rule for moving between points. The rule is simple: at each point, (1) get a direction, and (2) move a small distance in that direction. Repeat this until the end of the interval. In this context, the direction is a slope of the tangent line and the distance is the step size between the <m>t</m>-values.
		</p>

		<p>	
			For example, suppose we wanted to find the position of an object at <m>(0,4)</m> that moved in a straight line with slope <m>-2</m>. Where the next point is positioned depends on the step size we are using. Here are two examples:
		</p>

		<sidebyside widths="6% 38% 50% 6%" valign="middle">
			<p/>
			<p>
				<md>
					<mrow> (0,4) \amp \longrightarrow (1,7) \amp \text{(step size = 1)} </mrow>
					<mrow> (0,4) \amp \longrightarrow (0.5,5.5) \amp \text{(step size = 0.5)} </mrow>
				</md>
			</p>
			<p>
				<image>
					<latex-image>
						\begin{tikzpicture}[samples=50]
	
							% === colors ===
							\def\fColor{blue}			\def\fFill{\fColor!15}
							\def\gColor{green!60!black}	\def\gFill{\gColor!15}

							% === figure/domain/tick bounds ===
							\def\tmin{0.6}	\def\tmax{2.2}
							\def\ymin{-0.9}	\def\ymax{4.8}
							\def\ta{1}
							\def\yta{2}
							\def\dya{1.5}
							\def\ha{0.25} \def\hb{1} 
							\def\s{0.8}

							\begin{axis}[
								width=12cm, height=8cm, scale=0.5,
								xlabel={$t$}, ylabel={$y$},
								%title={Euler's Method Step 1},
								title style={font=\small},
								grid=both,
								%tick style={thick},
								line width=1pt,
								axis lines=middle,
								xtick distance=1, ytick distance=2,
								minor x tick num=1, minor y tick num=1,
								xmin=\tmin, xmax=\tmax, ymin=\ymin, ymax=\ymax,
								xticklabel style={yshift=0.0em, font=\scriptsize},
								yticklabel style={font=\scriptsize},
							]
							
								% Read and plot data from file
								\addplot+ [only marks] coordinates {
									(\ta, \yta)
									(\ta+\ha, \yta+\dya*\ha)
									(\ta+\hb, \yta+\dya*\hb)
								};
								\addplot+ [black, no marks, dashed] (\ta, \yta) -- ({\ta+\hb}, {\yta+\dya*\hb});

								\node[font=\scriptsize] at (1,	0.3)	{slope: $-2$};
								\node[font=\scriptsize] at (3,	0.3)	{slope: $0$};
								\node[font=\scriptsize] at (5,	0.3)	{slope: $3$};
							\end{axis}
						\end{tikzpicture}
					</latex-image>
				</image>
			</p>
			<p/>
		</sidebyside>
	</paragraphs>

	<paragraphs><title> A Concrete Introduction to Euler's Method  </title>
		<p>
			Before deriving the general formula for Euler's Method, let's walk through the process on a specific example. For clarity, we will use a large step size to illustrate the method, but in practice, you would typically use a smaller step size to get a more accurate approximation.
		</p>

		<p>
			Consider the initial value problem
			<me>
				y'(t) = 6t + y(t), \quad y(0) = -2, \quad t \text{ in } [0, 1.5].
			</me>
			Let's approximate the solution at the equally-spaced <m>t</m>-values: <m>0, 0.5, 1, 1.5</m>. A complete approximation will consist of the <m>y</m>-values from the following four points:   
		</p>

		<me>
			(0,\ y(0)),\quad (0.5,\ y(0.5)),\quad (1,\ y(1)),\quad (1.5,\ y(1.5)).
		</me>

		<p>
			The initial condition, <m>y(0) = -2</m>, gives us the first point and this is where Euler's Method officially begins.
		</p>

		<p>
			From our current position, <m>(0, -2)</m>, we need the direction (i.e., slope, <m>y'(0)</m>) that our solution, <m>y</m>, moves along at <m>t=0</m>. Notice that the differential equation is basically machine that outputs <m>y'(t)</m> values for any <m>t</m>. In particular, for <m>t = 0</m> we get
		</p>

		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=0}{\quad\longrightarrow\quad} 
			y'(0) = 6(0) + y(0) 
			\quad\longrightarrow\quad
			y'(0) = -2.
		</me>

		<p>
			This slope says that when <m>t</m> increases by <m>1</m>, <m>y</m> changes by <m>-2</m>. But, you can also say that when <m>t</m> increases by <m>h</m>, <m>y</m> changes by <m>-2\cdot h</m> since both lead to the same slope:
		</p>

		<me>
			\text{slope}\ = -2:\quad
			-\frac{2}{1}\
			\left(\frac{\text{down}\ 2}{\text{right}\ 1}\right)
			\ \ \text{and}\ \
			-\frac{2\cdot h}{1\cdot h}\
			\left(\frac{\text{down}\ 2h}{\text{right}\ h}\right)
		</me>

		<p>
			Thus, from <m>(0, -2)</m>, <m>t</m> moves right by <m>0.5</m> and <m>y</m> moves down by <m>-2\cdot 0.5 = -1</m>, giving the next approximation as <m>y(0.5) \approx -3</m> and the new position <m>(0.5, -3)</m>.
		</p>

		<p>
			Now, we repeat the process. From our new position, <m>(0.5, -3)</m>, we need the slope at <m>t = 0.5</m>, which comes directly from the differential equation:
		</p>

		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=0.5}{\quad\longrightarrow\quad} 
			y'(0.5) = 6(0.5) + y(0.5) 
			\quad\longrightarrow\quad
			y'(0.5) = 0.
		</me>

		<p>
			A zero slope says that <m>y</m> does not change at all. So, <m>y(1) \approx -3</m> and the new position is <m>(1, -3)</m>.
		</p>

		<p>
			Finally, <m>(1, -3)</m>, we compute the slope at <m>t = 1</m>:
		</p>
		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=1}{\quad\longrightarrow\quad} 
			y'(1) = 6(1) + y(1) 
			\quad\longrightarrow\quad
			y'(1) = 3.
		</me>

		<p>
			Here, when <m>t</m> increases by <m>0.5</m>, <m>y</m> moves up by <m>3\cdot 0.5 = 1.5</m>. So the last value is <m>y(1.5) \approx -1.5</m> and the complete approximation is given by the values:
		</p>

		<sidebyside widths="6% 38% 50% 6%" valign="middle">
			<p/>
			<p>
				<md>
					<mrow> y(0)		\amp \approx -2.0,</mrow>
					<mrow> y(0.5)	\amp \approx -3.0,</mrow>
					<mrow> y(1)		\amp \approx -3.0,</mrow>
					<mrow> y(1.5)	\amp \approx -1.5.</mrow>
				</md>
			</p>
			<p>
				<image>
					<latex-image>
							\begin{tikzpicture}[samples=50]
		
								% === colors ===
								\def\fColor{blue}			\def\fFill{\fColor!15}
								\def\gColor{green!60!black}	\def\gFill{\gColor!15}

								% === figure/domain/tick bounds ===
								\def\tmin{-0.2}	\def\tmax{1.8}
								\def\ymin{-4.9}	\def\ymax{1.8}
								\def\tticks{1, 2}
								\def\yticks{2, 4}
								\def\dyA{-2} \def\dyB{0} \def\dyC{3}
								\def\h{0.5} \def\s{0.5}


								% === Function definitions ===
								\newcommand{\f}[1]{e^(#1)}	\def\ftex{e^t}
								\def\ta{0}	\def\b{2}
								\def\c{1.13}

								\begin{axis}[
									width=24cm, height=8cm, scale=0.25,
									xlabel={$t$}, ylabel={$y$},
									%title={Euler's Method Step 1},
									title style={font=\small},
									grid=both,
									%tick style={thick},
									line width=1pt,
									axis lines=middle,
									xtick distance=0.5, ytick distance=2,
									minor x tick num=0, minor y tick num=1,
									xmin=\tmin, xmax=\tmax, ymin=\ymin, ymax=\ymax,
									xticklabel style={yshift=1.5em, font=\scriptsize},
									yticklabel style={font=\scriptsize},
								]
								
									% Read and plot data from file
									\addplot+ [only marks] coordinates {
										(0.0,-2.0)
										(0.5,-3.0)
										(1.0,-3.0)
										(1.5,-1.5)
									};
									\addplot+ [black, no marks, -&gt;] (0.0, -2.0) -- ({0.0+\h*\s}, {-2.0+\dyA*\h*\s});
									\addplot+ [black, no marks, -&gt;] (0.5, -3.0) -- ({0.5+\h*\s}, {-3.0+\dyB*\h*\s});
									\addplot+ [black, no marks, -&gt;] (1.0, -3.0) -- ({1.0+\h*\s}, {-3.0+\dyC*\h*\s});

									\node[font=\scriptsize] at (0.22,	-4.3)	{slope: $-2$};
									\node[font=\scriptsize] at (0.68,	-4.3)	{slope: $0$};
									\node[font=\scriptsize] at (1.18,	-4.3)	{slope: $3$};
								\end{axis}
							\end{tikzpicture}
					</latex-image>
				</image>
			</p>
			<p/>
		</sidebyside>
	</paragraphs>

	<paragraphs><title> How Euler's Method Works </title>

		<p>
			Euler's Method is a step-by-step process for approximating the solution to a differential equation of the form
		</p>

		<me>
			y'(t) = f(t, y), \quad y(t_0) = y_0, \quad \text{for } t \text{ in } [t_0, t_N].
		</me>

		<p>
			The goal is to estimate the values of the solution <m>y(t)</m> at a sequence of evenly spaced time points:
		</p>

		<me>
			t_0,\ t_1,\ t_2,\ \ldots,\ t_N,
		</me>

		<p>
			where each is separated by the step size, <m>h</m> (i.e., <m>t_{k+1} = t_k + h</m>). For convenience, we'll use the shorthand <m>y_k = y(t_k)</m>, so the solution points we want to approximate are:
		</p>

		<me>
			(t_0, y_0),\ (t_1, y_1),\ (t_2, y_2),\ \ldots,\ (t_N, y_N).
		</me>

		<p>
			Since the initial condition <m>y(t_0) = y_0</m> is given, we know the first point, <m>(t_0, y_0)</m>. So it makes sense to always start here.
			
			
			The remaining points are approximated using the differential equation itself, which provides the slope of the solution at each point.
			At each step, you know your current position <m>(t_k, y_k)</m>, and the differential equation tells you the direction to move to get the next position. But, how do you use this information to get to the next position <m>(t_{k+1}, y_{k+1})</m>?
		</p>

	</paragraphs>

	<paragraphs><title> Using the Slope to Move in a Straight Line </title>
		<p>
			Suppose you have a line in slope-intercrpt form, <m>y = mx+b</m>. Recall that the fractional form of the slope, <m>m</m>, was often interpreted as the <q>rise</q> over the <q>run</q>, meaning you can get from one point to another by moving up (if the slope is positive) by the <q>rise</q> and left by the <q>run</q>.
		</p>

		<p>
			For example, a line in the form
		</p>

		<me>
			y = \frac32 x - 1
		</me>
		
		<p>
			has a <m>y</m>-intercept of <m>-1</m>, which means it passes through <m>(0,-1)</m>. The slope, <m>\frac32</m>, indicates a rise of <m>3</m> and a run of <m>2</m>, so we get to the point <m>(2,2)</m> from the point <m>(0,-1)</m> by moving up <m>3</m> and right <m>2</m> as shown in <xref ref="rise-3-run-2"/>.
		</p>

		<p>
			In this example, the rise and run were simply the numerator and denominator. However, a different rise and run value could come from multiplying the numerator and denominator by any non-zero number. For example, all of the following are the same slope with a different rise and run:  
		</p>

		<me>
			\frac{\text{rise}}{\text{run}}\quad\rightarrow\quad \frac32 = \frac{6}{4} = \frac{3\pi}{2\pi} = \frac{\frac32}{1} = \frac{\frac32h}{h} =\ \ldots.
		</me>

		<p>
			as illustrated in <xref ref="one-slope-multiple-rise-run"/>.
		</p>

		<figure xml:id="one-slope-multiple-rise-run"><caption>Same Slope, Different Rise and Runs</caption>
			<sidebyside widths="7.6% 23.4% 6% 25% 6% 24.6% 7.4%" valign="top">
				<p/>
				<figure xml:id="rise-3-run-2"><caption>Rise <m>3</m>, run <m>2</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{2} \def\rise{3} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}						% point coordinates
							\def\tmin{-0.8} \def\tmax{3.9}
							\def\ymin{-0.8} \def\ymax{4.8}
							\def\tticks{1,3} \def\yticks{1,4}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,4}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.6]
								
								% === t-axis and grid ===
								\foreach \tk in \tgrid{\draw[thin, gray!50!white] (\tk,\ymin) -- (\tk,\ymax);}
								\foreach \tk in \tticks{
									\draw (\tk,-0.1) -- (\tk,0.1)
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway, font=\small] {$\tk$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \yk in \ygrid{\draw[thin, gray!50!white] (\tmin,\yk) -- (\tmax,\yk);}
								\foreach \yk in \yticks{
									\draw (-0.1,\yk) -- (0.1,\yk)
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway, font=\small] {$\yk$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.2, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=0cm, inner sep = 1pt, midway, font=\small] {$\rise$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$\run$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.06cm, font=\small] {$(\ta,\ya)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.3cm, yshift=-0.15cm, font=\small] {$(3,4)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>
				<p/>
				<figure xml:id="rise-1pt5-run-1"><caption>Rise <m>\frac32</m>, run <m>1</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{1} \def\rise{1.5} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}					% point coordinates
							\def\tmin{-0.8} \def\tmax{3.4}
							\def\ymin{-0.8} \def\ymax{3.9}
							\def\tticks{1,2,3} \def\yticks{1,2,3}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,3}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.7]
								
								% === t-axis and grid ===
								\foreach \tk in \tgrid{\draw[thin, gray!50!white] (\tk,\ymin) -- (\tk,\ymax);}
								\foreach \tk in \tticks{
									\draw (\tk,-0.1) -- (\tk,0.1)
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway, font=\small] {$\tk$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \yk in \ygrid{\draw[thin, gray!50!white] (\tmin,\yk) -- (\tmax,\yk);}
								\foreach \yk in \yticks{
									\draw (-0.1,\yk) -- (0.1,\yk)
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway, font=\small] {$\yk$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.4, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=-0.1cm, inner sep = 1pt, midway, font=\small] {$\sfrac32$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$\run$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.06cm, font=\small] {$(\ta,\ya)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.1cm, font=\small] {$(2,\frac52)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>	
				<p/>
				<figure xml:id="rise-mh-run-h"><caption>Rise <m>mh</m>, run <m>h</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{2} \def\rise{3} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}						% point coordinates
							\def\tmin{-0.8} \def\tmax{4.3}
							\def\ymin{-0.8} \def\ymax{4.8}
							\def\tticks{1,3} \def\yticks{1,4}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,4}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.6]
								
								% === t-axis and grid ===
								\foreach \k in {0,1}{
									\draw[thin, gray!50!white] ({\ta + \k*\run},\ymin) -- ({\ta + \k*\run},\ymax);
									\draw[black] ({\ta + \k*\run},-0.1) -- ({\ta + \k*\run},0.1) 
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway] {$t_{\k}$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \k in {0,1}{
									\draw[thin, gray!50!white] (\tmin, {\ya + \k*\rise}) -- (\tmax, {\ya + \k*\rise});
									\draw (-0.1, {\ya + \k*\rise}) -- (0.1, {\ya + \k*\rise})
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway] {$y_{\k}$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.5, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=0cm, inner sep = 1pt, midway, font=\small] {$\frac32h$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$h$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.55cm, yshift=-0.1cm, font=\small] {$(t_0,y_0)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.2cm, font=\small] {$(t_1,y_1)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

								% === extra h (run) label ===
								\draw[blue!40!green, thick, -&gt;]
										(\ta + 0.3, -0.45) -- (\ta + \run - 0.25, -0.45)
										node[fill=white, inner sep = 1pt, xshift=0cm, midway, font=\small] {$h$};

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>
				<p/>
			</sidebyside>
		</figure>

		<p>
			In general, if <m>m</m> is the slope, then we also have
		</p>

		<me>
			\frac{\text{rise}}{\text{run}}\quad\rightarrow\quad m = \frac{m}{1} = \frac{m\cdot h}{1\cdot h} = \frac{mh}{h},
		</me>

		<p>
			where the last expression has a rise of <m>mh</m> and a run of <m>h</m>. This shows that a run of <m>h</m> to the next point must be paired with a rise of <m>mh</m>. In particular, 
		</p>

		<me>
			\text{A run of}\ h\ \text{from}\ (t_0, y_0)\ \text{leads to}\ (t_1, y_1) = (t_0 + h, y_0 + mh),
		</me>
	</paragraphs>

	<paragraphs><title> The Differential Equation as a Slope Generator </title>
		<p>
			Euler's method creates an approximation one point at a time starting with the initial condition, <m>(t_0, y_0)</m>. From there, it moves in a straight line to another point, <m>(t_1, y_1)</m>, gets a new direction, and continues to the next point, <m>(t_2, y_2)</m>. It repeats this move/redirect process until it reaches the final point, <m>(t_N, y_N)</m>. 
		</p>

		<p>
			This makes sense, but where does it get the new direction at each new position? It turns out that the differential equation itself is the perfect tool to give the slope at any point. For example, if the differential equation is given by
			<me>
				y'(t) - ty(t) = 2 - t^2,
			</me>
			then the slope of the solution, <m>y(t)</m>, comes from the <m>y'(t)</m> term, so let's isolate it:
			<men xml:id="slope-generator-eqn">
				y'(t) = ty(t) + 2 - t^2.
			</men>
		</p>

		<p>
			Now, suppose we want the slope at the point <m>(3,1)</m>. This point corresponds to <m>t = 3</m> and <m>y(3) = 1</m>. So, plugging <m>t = 3</m> into <xref ref="slope-generator-eqn"/> gives the slope at this point:
			<me>
				y'(3) = (3)y(3) + 2 - (3)^2 
				= 3(1) + 4 - 9
				= -2.
			</me>
			Thus, at the point <m>(3,1)</m>, the solution moves in a direction with slope <m>-2</m>. This means that running right by <m>h = 0.5</m>, moves <m>y</m> by <m>-2\cdot 0.5 = -1</m> (i.e., down by <m>1</m>), and ending up at <m>(3.5, 0)</m>.
		</p>

		<p>
			In this sense, the differential equation behaves like a machine that generates the slope at any given point <m>(t_k, y_k)</m>.
		</p>
	</paragraphs>

	<paragraphs><title> A Single Step of Euler's Method </title>

		<p>
			Suppose you want move from a known current position, <m>(t_{\text{cur}}, y_{\text{cur}})</m> to a new position, <m>(t_{\text{new}}, y_{\text{new}})</m> along a striaght line with a step size of <m>h</m> (distance between <m>t_{\text{cur}}</m> and <m>t_{\text{new}}</m>).
		</p>

		<p>
			The slope, denoted <m>y'_{\text{cur}}</m>, is found by plugging <m>(t_{\text{cur}}, y_{\text{cur}})</m> into the differential equation, however, the run is preset to <m>h</m>, so we must adjust the slope as
		</p>
		
		<me>
			\text{slope:}\quad y'_{\text{cur}} = \frac{y'_{\text{cur}}}{1} = \frac{h \cdot y'_{\text{cur}}}{h} \quad
			\begin{array}{l}
				\us{\,}{\leftarrow}\ \text{rise} \\
				\leftarrow\ \text{run}
			\end{array}
		</me>

		<p>
			Therefore, to get to the new position, we need to add the run to <m>t_{\text{cur}}</m> and the rise to <m>y_{\text{cur}}</m>. In particular, the new point is given by
		</p>

		<md>
			<mrow>
				(t_{\text{new}},\ y_{\text{new}})
				\amp= (t_{\text{cur}} + \text{run},\ y_{\text{cur}} + \text{rise})
			</mrow>
			<mrow>
				\amp= (t_{\text{cur}} + h,\ y_{\text{cur}} + h\cdot y'_{\text{cur}}).
			</mrow>
		</md>

		<p>
			Pulling out the formula for just the <m>y</m>-coordinate, we have
		</p>

		<me>
			y_{\text{new}} = y_{\text{cur}} + h\cdot y'_{\text{cur}}
		</me>

		<p>
			and what we have here is Euler's method, albiet an informal version. The formal version, which we will cover next, replaces <m>\text{cur}</m> with <m>k</m> and <m>\text{new}</m> with <m>k+1</m>.
		</p>
	</paragraphs>

	<paragraphs><title> Euler's Method </title>
		<p>
			Euler's method operates on a very intuitive principle: starting from an initial point, the method uses the differential equation itself to take small steps along the direction of the slope given by the equation. At each step, the method calculates the slope of the unknown function at the current point, then moves a small distance in the direction of this slope to find the next point. By repeating this process, Euler's method generates a sequence of points that approximates the true solution curve of the differential equation.
		</p>

		<p>
			Starting on the left, the goal of Euler's method is to generate the points:
		</p>

		<me>
			(t_0, y_0) \quad\rightarrow\quad (t_1, y_1) \quad\rightarrow\quad (t_2, y_2) \quad\rightarrow\quad \ldots \quad\rightarrow\quad (t_N, y_N)
		</me>

		<p>
			such that they are close to the curve of the analytical solution to the initial value problem
		</p>

		<me>
			y'(t) = f(t, y), \quad y(t_0) = y_0, \quad \text{for } t \text{ in } [t_0, t_N].
		</me>

		<p>
			Moving from one point to another follows the same process described in the previous section. Recall, to move from <m>(t_{\text{k}},\ y_{\text{k}})</m> to <m>(t_{\text{k+1}},\ y_{\text{k+1}})</m>, we used the formula: 
		</p>

		<me>
			(t_{\text{k+1}},\ y_{\text{k+1}}) = (t_{\text{k}} + h,\ y_{\text{k}} + h\cdot y'_{\text{k}}).
		</me>

		<p>
			where, in this context, <q><m>\text{k}</m></q> denotes the current step and <q><m>\text{k+1}</m></q> the next one. This leads to the following formula for Euler's method:
		</p>

		<me>
			y_{k+1} = y_k + h\cdot y_k'
		</me>

		<p>
			where <m>y_0</m> is known and the rest are computed for <m>k = 0, 1, 2, \ldots, N-1</m>, which leads us to the complete method, summarized as follows.
		</p>

		<exploration xml:id="euler-method"><title> Euler's Method </title>
			<p>
				An approximate solution to the first order differential equation
				<men xml:id="euler-method-de">
					y' = f(t, y), \quad y(t_0) = y_0
				</men>
				can be found on the interval <m>[t_0, t_N]</m> through the following steps...
			</p>
			<dl width="narrow">
				<li xml:id="eulers-method-step-1"><title> Select Step for <m>t_{1}, t_{2}, ..., t_{N}</m> </title>
					<p>
						Select a step size, <m>h</m>, to set <m>t_0,\ t_1,\ t_2,\ ...,\ t_{N}</m>, inside <m>[t_0, t_N]</m> and in the <m>t_k</m> column of the table below.
					</p>
				</li>
				<li xml:id="eulers-method-step-2"><title> Compute <m>y_{1}, y_{2}, ..., y_{N}</m> </title>
					<p>
						For each <m>k = 0, 1, 2, ..., N-1</m>, compute
						<me>
							y_{k+1} = y_k + hf(t_k,y_k), \quad y_0\ \text{is given}.
						</me>
						That is, compute the <m>y_k</m> column of the table:
						<tabular>
							<col right="minor" halign="center"/>
							<col halign="left"/>
							<col halign="center"/>
							<row halign="center" bottom="minor">
								<cell><m>t_k</m></cell>
								<cell><m>y_k</m></cell>
								<cell bottom="none"/>
							</row>
							<row>
								<cell><m>t_0</m></cell>
								<cell><m>y_0 = y_0</m></cell>
								<cell><m>(\text{Given})</m></cell>
							</row>
							<row>
								<cell><m>t_1</m></cell>
								<cell><m>y_1 = y_0 + hf(t_0,y_0)</m></cell>
								<cell><m>(k = 0)</m></cell>
							</row>
							<row>
								<cell><m>t_2</m></cell>
								<cell><m>y_2 = y_1 + hf(t_1,y_1)</m></cell>
								<cell><m>(k = 1)</m></cell>
							</row>
							<row halign="center">
								<cell><m>\vdots</m></cell>
								<cell><m>\vdots</m></cell>
								<cell><m>\vdots</m></cell>
							</row>
							<row>
								<cell><m>t_{N-1}</m></cell>
								<cell><m>y_N = y_{N-1} + hf(t_{N-1},y_{N-1})</m></cell>
								<cell><m>(k = N-1)</m></cell>
							</row>
						</tabular>
					</p>
				</li>
			</dl>
		</exploration>

		<corollary>
			<sidebyside width="100%" margins="0%">
				<interactive xml:id="euler-ivp-tool"
					platform="jsxgraph"
					aspect="1:1"
					dark-mode-enabled="yes"
					source="code/jsxgraph/eulers-method/euler-ivp-tool.js"
				>
					<sidebyside width="100%">
						<slate xml:id="euler-ivp-tool-plot1" surface="jsxboard" aspect="1:1" />
					</sidebyside>
					<static>
						<image source="code/jsxgraph/img-labels/t.png" width="70%"> Need to Add </image>
					</static>
				</interactive>
			</sidebyside>
		</corollary>

	</paragraphs>

	<paragraphs><title> Worked Examples </title>
		<example><title> Euler's Method Example </title>
			<statement>
				<p>
					Use Euler's method to approximate the solution to the differential equation
					<me>
						y' = t + y, \quad y(0) = -\frac{7}{8}
					</me>
					over the interval <m>[0, 1.5]</m> with a step size of <m>h = 0.5</m>.
				</p>
			</statement>

			<solution>

				<p>
					<xref ref="eulers-method-step-1" text="title"/>. The step size is <m>h = 0.5</m>, so the approximation locations are
					<m>t_0 = 0, t_1 = 0.5, t_2 = 1.0, t_3 = 1.5</m>.
				</p>

				<p>
					<xref ref="eulers-method-step-2" text="title"/>. The initial condition gives the first value in our approximation, <m>y_0 = -\frac{7}{8} = -0.875</m>.
				</p>

				<p>
					Now, we can use the formula
					<me>
						y_{k+1} = y_k + h\left(t_k + y_k\right)
					</me>
					to find <m>y_1</m>, <m>y_2</m> and <m>y_3</m> as follows:
				</p>

				<sidebyside widths="5% 8% 82% 5%" valign="middle">
					<p/>
					<p>
						<md>
							<mrow> \text{G}	\amp\text{iven} </mrow>
							<mrow> k		\amp = 0 </mrow>
							<mrow> k		\amp = 1 </mrow>
							<mrow> k		\amp = 2 </mrow>
						</md>
					</p>
					<p>
						<md>
							<mrow> y_0	\amp = -0.875 </mrow>
							<mrow> y_1	\amp = y_0 + h\left(t_0 + y_0\right) = -0.875 + 0.5\left(0 - 0.875\right) </mrow>
							<mrow> y_2	\amp = y_1 + h\left(t_1 + y_1\right) = -1.3125 + 0.5\left(0.5 - 1.3125\right) </mrow>
							<mrow> y_3	\amp = y_2 + h\left(t_2 + y_2\right) = -1.5625 + 0.5\left(1.0 - 1.5625\right) </mrow>
						</md>
					</p>
					<p/>
				</sidebyside>

				<p>
					The simplified calculations are summarized in the following table:
				</p>

				<tabular>
					<col right="minor" halign="center"/>
					<col right="minor" halign="left"/>
					<col halign="center"/>
					<row halign="center" bottom="minor">
						<cell><m>k</m></cell>
						<cell><m>t_k</m></cell>
						<cell><m>y_k</m></cell>
					</row>
					<row>
						<cell><m>0</m></cell>
						<cell><m>0.0</m></cell>
						<cell><m>-0.875</m></cell>
					</row>
					<row>
						<cell><m>1</m></cell>
						<cell><m>0.5</m></cell>
						<cell><m>-0.75</m></cell>
					</row>
					<row>
						<cell><m>2</m></cell>
						<cell><m>1.0</m></cell>
						<cell><m>-0.5</m></cell>
					</row>
					<row halign="center">
						<cell><m>3</m></cell>
						<cell><m>1.5</m></cell>
						<cell><m>-0.125</m></cell>
					</row>
				</tabular>

				<p>
					Thus, the approximate solution to the initial-value problem is
					<me>
						y(0) \approx -\frac{7}{8}, \quad y(0.5) \approx -\frac{3}{4}, \quad y(1.0) \approx -\frac{1}{2}, \quad y(1.5) \approx -\frac{1}{8}.
					</me>
				</p>

				<p>
					We can visualize the approximation by plotting the points <m>(t_k, y_k)</m> and connecting them with line segments. The exact solution to the initial-value problem is given by
					<me>
						y(t) = \frac{1}{8}e^t - t - 1.
					</me>
				</p>

				<p>
					The following plot shows the approximation and the exact solution.
				</p>

				<image xml:id="sageplot-euler-approximation">

					<sageplot variant="2d">
						y = lambda x : (1/8)*exp(x)-x-1
						euler = lambda x, y, dx : y + dx*(x + y)
						y0 = -7/8
						x0, h, xF = 0, 0.5, 1.5
						ymin, ymax = -3, 1

						y_data = [(x0, y0)]
						yp = y0

						for xp in xsrange(x0, xF, h):
							yp = euler(xp, yp, h)
							y_data.append((xp + h, yp))

						xticks = [0, 0.5, 1, 1.5, 2]
						yticks = [i for i in range(ymin, ymax)]

						grid_rgbcolor = (0.9, 0.9, 0.9)
						grid = plot([], ymin=ymin, ymax=ymax, fontsize=16, ticks=[xticks, yticks],)

						for gx in xsrange(x0, xF, 0.25, include_endpoint=True):
							grid += line([(gx, ymin),(gx, ymax)], rgbcolor=grid_rgbcolor)
						for gy in xsrange(ymin, ymax, 1, include_endpoint=True):
							grid += line([(x0,  gy),(xF, gy)], rgbcolor=grid_rgbcolor)

						y_plot = plot(y, x0, xF, rgbcolor='red', thickness=1,)
						yn_plot = list_plot(y_data, markeredgecolor="black", rgbcolor=(0.2,0.8,0.1), pointsize=40)
						y_plot + yn_plot + grid

					</sageplot>
				</image>

				<p>
					The red curve is the exact solution, while the green points are the approximated values at <m>t = 0, 0.5, 1.0, 1.5</m>.
					The blue line segments connect the points in the approximation, showing how Euler's method steps through the solution.
				</p>

				<p>
					The following plot shows the approximation and the exact solution, with a grid for better visualization.
				</p>

				<p>
					<image xml:id="sageplot-polynomial-approximation">

						<sageplot variant="2d">
							y = lambda x : (1/8)*exp(x)-x-1
							euler = lambda x, y, dx : y + dx*(x + y)
							y0 = -7/8
							x0, h, xF = 0, 0.5, 1.5
							ymin, ymax = -3, 1

							y_data = [(x0, y0)]
							yp = y0

							for xp in xsrange(x0, xF, h):
								yp = euler(xp, yp, h)
								y_data.append((xp + h, yp))

							xticks = [0, 0.5, 1, 1.5, 2]
							yticks = [i for i in range(ymin, ymax)]

							grid_rgbcolor = (0.9, 0.9, 0.9)
							grid = plot([], ymin=ymin, ymax=ymax, fontsize=16, ticks=[xticks, yticks],)
							

							for gx in xsrange(x0, xF, 0.25, include_endpoint=True):
								grid += line([(gx, ymin),(gx, ymax)], rgbcolor=grid_rgbcolor)
							for gy in xsrange(ymin, ymax, 1, include_endpoint=True):
								grid += line([(x0,  gy),(xF, gy)], rgbcolor=grid_rgbcolor)

							y_plot = plot(y, x0, xF, rgbcolor='red', thickness=1,)
							yn_plot = list_plot(y_data,  markeredgecolor="black", rgbcolor=(0.2,0.8,0.1), pointsize=40)
							y_plot + yn_plot + grid

						</sageplot>
					</image>
				</p>

				<image width="100%">
					<latex-image>
						% User Defined Parameters
						\def\a{0} 		% interval start
						\def\b{1} 		% interval end
						\def\h{0.2} 	% stepsize
						\def\round{2}	% decimal rounding
						\def\s{5}  		% scaling factor

						\begin{tikzpicture}[scale=\s]

							\pgfkeys{/pgf/number format/.cd,fixed,precision=\round}
						
							% Calculate number of partitions
							\pgfmathsetmacro{\N}{(\b-\a)/\h}
							
							% Draw the x-axis
							\draw[-&gt;,thick] (\a - 2*\h/\s,0) -- (\b + 2*\h/\s,0) node[right] {$x$};

							% Draw the partition points and labels
							\foreach \i in {0,...,\N}
							{
								\pgfmathsetmacro{\currentPoint}{\a + \i*\h}
								\draw (\currentPoint,0.1/\s) -- (\currentPoint,-0.1/\s) node[below] {$\pgfmathprintnumber{\currentPoint}$};
								\draw 							(\currentPoint,-0.5/\s) node[below] {$t_{\i}$};

							}
							
						\end{tikzpicture}
					</latex-image>
				</image>

				<p>
					<md>
						<mrow> y'(t_k) 										\amp = (y(t_k))^2 - t_k </mrow>
						<mrow> \frac{y(t_{k+1}) - y(t_k)}{h}	\amp = (y(t_k))^2 - t_k </mrow>
						<mrow> \frac{y_{k+1} - y_k}{h}	\amp = (y_k)^2 - t_k </mrow>
						<mrow> y(t_{k+1}) - y(t_k) 							\amp = h\left((y(t_k))^2 - t_k\right) </mrow>
						<mrow> y(t_{k+1}) 									\amp = y(t_k) + h\left((y(t_k))^2 - t_k\right) </mrow>
					</md>
				</p>
			</solution>
		</example>

		<example><title> Analytical and Numerical Solutions </title>
			<statement>
				<p>
					Consider the differential equation
					<me>
						y' + 4ty = 0, \, y(0) = 1
					</me>.
					<ol>
						<li>
							<p>
								Find the analytical solution to this equation using the method of separation of variables.
							</p>
						</li>
						<li>
							<p>
								Use Euler's method with a step size of <m>h = 0.1</m> to approximate the solution at <m>t = 0.5</m>. 
							</p>
						</li>
						<li>
							<p>
								Compare the analytical solution with the numerical approximation obtained from Euler's method.
							</p>
						</li>
					</ol>
				</p>
			</statement>

			<solution>
				<p>
					To solve the differential equation <me>y' + 4ty = 0</me> using the method of separation of variables, we separate the variables as follows:
					<me>
						\frac{dy}{y} = -4t \, dt
					</me>
					Integrating both sides gives:
					<me>
						\ln |y| = -2t^2 + C
					</me>
					Exponentiating both sides results in:
					<me>
						y = Ce^{-2t^2}
					</me>
					Since the initial condition, <m>y(0) = 1</m>, gives <m>C = 1</m>, the analytical solution is:
					<me>
						y(t) = e^{-2t^2}
					</me>
				</p>

				<p>
					Next, we apply Euler's method to approximate the solution at <m>t = 0.5</m>. The general formula for Euler's method is:
					<me>
						y_{k+1} = y_k + h f(t_k, y_k)
					</me>
					where <m>f(t, y) = -4ty</m> and <m>h=0.1</m>. So, we can update the formula as:
				</p>

				<me>
					y_{k+1} = y_k - 0.4 t_k y_k \quad \text{where}\ y_0 = 1.
				</me>

				<p>
					For <m>k = 0, 1, \ldots, 4</m>, we contruct the following table:
				</p>

				<tabular>
					<col halign="center" right="minor" />
					<col halign="center" right="minor" />
					<col halign="left" right="minor" />
					<col halign="left" />
					<row halign="center" bottom="minor">
						<cell><m>k</m></cell>
						<cell><m>t_k</m></cell>
						<cell><m>y_k</m></cell>
						<cell><m>y_{k+1}</m></cell>
					</row>
					<row>
						<cell><m>0</m></cell>
						<cell><m>0.0</m></cell>
						<cell><m>y_0 = {\DLBa 1}</m></cell>
						<cell><m>y_1 = {\DLBa 1} + 0.1(-4 \cdot 0.0 \cdot {\DLBa 1}) = {\DLGa 1}</m></cell>
					</row>
					<row>
						<cell><m>1</m></cell>
						<cell><m>0.1</m></cell>
						<cell><m>y_1 = {\DLBa 1}</m></cell>
						<cell><m>y_2 = {\DLBa 1} + 0.1(-4 \cdot 0.1 \cdot {\DLBa 1}) = {\DLGa 0.96}</m></cell>
					</row>
					<row>
						<cell><m>2</m></cell>
						<cell><m>0.2</m></cell>
						<cell><m>y_2 = {\DLBa 0.96}</m></cell>
						<cell><m>y_3 = {\DLBa 0.96} + 0.1(-4 \cdot 0.2 \cdot {\DLBa 0.96}) = {\DLGa 0.8832}</m></cell>
					</row>
					<row halign="center">
						<cell><m>3</m></cell>
						<cell><m>0.3</m></cell>
						<cell><m>y_3 = {\DLBa 0.8832}</m></cell>
						<cell><m>y_4 = {\DLBa 0.8832} + 0.1(-4 \cdot 0.3 \cdot {\DLBa 0.8832}) \approx {\DLGa 0.7772}</m></cell>
					</row>
					<row halign="center">
						<cell><m>4</m></cell>
						<cell><m>0.4</m></cell>
						<cell><m>y_4 = {\DLBa 0.7772}</m></cell>
						<cell><m>y_5 = {\DLBa 0.7772} + 0.1(-4 \cdot 0.4 \cdot {\DLBa 0.7772}) \approx {\DLGa 0.6529}</m></cell>
					</row>
				</tabular>

				<p>
					Since <m>t_5=0.5</m>, the approximation we are looking for is <m>y_5 \approx 0.6529</m>.
				</p>

				<p>
					Comparing this with the analytical solution at <m>t = 0.5</m>, we see the true value is:
					<me>
						y(0.5) = e^{-2(0.5)^2} = e^{-0.5} \approx 0.6065.
					</me>
					Although there is some error between the two values, it is more due to the step size we chose, rather than the method itself. A smaller step size would yield a more accurate approximation. For example, using <m>h = 0.001</m> gives the approximation: <m>y(0.5) \approx 0.6069</m>. 
				</p>
			</solution>
		</example>
	</paragraphs>

	<p>
		In summary, Euler's method is a powerful tool for approximating the solutions of differential equations that are challenging or impossible to solve analytically. By understanding and applying this method, students and professionals can gain insights into the behavior of complex systems described by such equations, even in the absence of exact solutions.
	</p>

	<p>
		This shift towards numerical approximation is not just a workaround but a powerful approach that expands our capacity to solve differential equations arising in complex systems where exact solutions are not readily derivable. Euler's method, as we will see, is the entry point into this expansive field of computational mathematics, demonstrating how straightforward concepts can approximate solutions to complex problems.
	</p>

</section>