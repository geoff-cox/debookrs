<section><title> Euler's Method </title>

	<p>
		In this section, we'll build intuition for the most common kind of numerical method — one that approximates the solution to an initial value problem by computing values of <m>y(t)</m> one step at a time. It might feel a little strange at first, but you're not solving the entire equation at once. Instead, you're just walking forward from one point to the next, building a trail of approximate values as you go.
	</p>

	<p>
		To give you an idea of how some of these methods work, imagine you are hiking through the woods in the fog from point <m>A</m> to <m>B</m>. Assuming there exists a best possible path, can you approximate if you only knew the information below?
		<ul>
			<li>
				<p>
					Your current position.
				</p>
			</li>
			<li>
				<p>
					The direction you should go from your current position.
				</p>
			</li>
		</ul>
	</p>

	<p>
		To make progress from point <m>A</m>, you walk in a direction for some time, then stop, note your current position and recalculate the new direction to walk. You repeat this process until, ideally, you are somewhere near point <m>B</m>.
	</p>

	<p>
		In this analogy, the solution you are trying to approximate is the best possible path from point <m>A</m> to <m>B</m>. The approximation is the collection of current positions (starting with <m>A</m>) you noted when you stopped to update your direction. This systematic process is precisely how some numerical methods work.
	</p>

	<exercise><title> What's the Tradeoff </title>
		<statement>
			<p>
				In the previous analogy, what trade-off do you think exists when approximating the best possible path?
			</p>
		</statement>
		<choices randomize="yes">
			<choice correct="yes">
				<statement>
					The more often you stop to recalculate your position, the more accurate your approximation, but the longer it takes.
				</statement>
				<feedback>
					Correct — stopping more often gives you a better approximation, but it also takes more time.
				</feedback>
			</choice>
			<choice>
				<statement>
					The less often you stop, the more accurate your approximation.
				</statement>
				<feedback>
					This is not true — stopping less often leads to a less accurate approximation.
				</feedback>
			</choice>
			<choice>
				<statement>
					The more often you stop, the less accurate your approximation.
				</statement>
				<feedback>
					This is not true — stopping more often leads to a more accurate approximation.
				</feedback>
			</choice>
			<choice>
				<statement>
					The direction you choose does not affect the accuracy of your approximation.
				</statement>
				<feedback>
					This is not true — the direction you choose is crucial for making progress toward the best path.
				</feedback>
			</choice>
		</choices>
	</exercise>

	<paragraphs><title> An Analogy </title>
		<p>
			Imagine you're a tiger hunting prey in a dense forest. You can't see the prey, but you can smell which direction it's in. So you head in that direction for 5 seconds, then stop to sniff the air again and adjust your course. You repeat this process — move a bit, check the scent, adjust — until you either find your prey or lose the trail.
		</p>

		<p>
			This is the essence of Euler’s Method. The tiger’s position every 5 seconds is like the numerical solution: a series of approximated locations. The prey’s true path is the exact, analytic solution to the differential equation. And the scent? That’s the derivative — the information that tells you which direction to go next.
		</p>

		<p>
			Just like the tiger, Euler’s Method doesn't know the full path in advance. It only knows where it is and which way to head — based on the differential equation — and it follows that direction one small step at a time.
		</p>
	</paragraphs>

	<paragraphs><title> Stepping Between Two Points </title>
		<p>
			Euler's method works by attempting to follow the graph of the solution, one point at a time. It can't see the solution, but it always knows what direction it would move at any given point. 
		</p>

		<p>	
			As an analogy, imagine you are playing a game where you must walk along a random path blindfolded. You are nudged in the direction of the path and must walk a distance of your choice where you can get another nudge. If the path is straight, you could follow it easily. But if the path curves, you might veer off course between nudges. A similar idea holds for Euler's method, except that it uses the slope of the solution's tangent line to determine the direction to move at each point.
		</p>
	</paragraphs>

	<paragraphs><title> Rule for Moving From One Point to the Next </title>
		<p>
			Starting with the initial condition, Euler's method produces a sequence of points, one-by-one, over some given interval. Therefore, it needs a rule for moving between points. The rule is simple: at each point, (1) get a direction, and (2) move a small distance in that direction. Repeat this until the end of the interval. In this context, the direction is a slope of the tangent line and the distance is the step size between the <m>t</m>-values.
		</p>

		<p>	
			For example, suppose we wanted to find the position of an object at <m>(0,4)</m> that moved in a straight line with slope <m>-2</m>. Where the next point is positioned depends on the step size we are using. Here are two examples:
		</p>

		<sidebyside widths="6% 38% 50% 6%" valign="middle">
			<p/>
			<p>
				<md>
					<mrow> (0,4) \amp \longrightarrow (1,7) \amp \text{(step size = 1)} </mrow>
					<mrow> (0,4) \amp \longrightarrow (0.5,5.5) \amp \text{(step size = 0.5)} </mrow>
				</md>
			</p>
			<p>
				<image>
					<latex-image>
						\begin{tikzpicture}[samples=50]
	
							% === colors ===
							\def\fColor{blue}			\def\fFill{\fColor!15}
							\def\gColor{green!60!black}	\def\gFill{\gColor!15}

							% === figure/domain/tick bounds ===
							\def\tmin{0.6}	\def\tmax{2.2}
							\def\ymin{-0.9}	\def\ymax{4.8}
							\def\ta{1}
							\def\yta{2}
							\def\dya{1.5}
							\def\ha{0.25} \def\hb{1} 
							\def\s{0.8}

							\begin{axis}[
								width=12cm, height=8cm, scale=0.5,
								xlabel={$t$}, ylabel={$y$},
								%title={Euler's Method Step 1},
								title style={font=\small},
								grid=both,
								%tick style={thick},
								line width=1pt,
								axis lines=middle,
								xtick distance=1, ytick distance=2,
								minor x tick num=1, minor y tick num=1,
								xmin=\tmin, xmax=\tmax, ymin=\ymin, ymax=\ymax,
								xticklabel style={yshift=0.0em, font=\scriptsize},
								yticklabel style={font=\scriptsize},
							]
							
								% Read and plot data from file
								\addplot+ [only marks] coordinates {
									(\ta, \yta)
									(\ta+\ha, \yta+\dya*\ha)
									(\ta+\hb, \yta+\dya*\hb)
								};
								\addplot+ [black, no marks, dashed] (\ta, \yta) -- ({\ta+\hb}, {\yta+\dya*\hb});

								\node[font=\scriptsize] at (1,	0.3)	{slope: $-2$};
								\node[font=\scriptsize] at (3,	0.3)	{slope: $0$};
								\node[font=\scriptsize] at (5,	0.3)	{slope: $3$};
							\end{axis}
						\end{tikzpicture}
					</latex-image>
				</image>
			</p>
			<p/>
		</sidebyside>
	</paragraphs>

	<paragraphs><title> A Concrete Introduction to Euler's Method  </title>
		<p>
			Before deriving the general formula for Euler's Method, let's walk through the process on a specific example. For clarity, we will use a large step size to illustrate the method, but in practice, you would typically use a smaller step size to get a more accurate approximation.
		</p>

		<p>
			Consider the initial value problem
			<me>
				y'(t) = 6t + y(t), \quad y(0) = -2, \quad t \text{ in } [0, 1.5].
			</me>
			Let's approximate the solution at the equally-spaced <m>t</m>-values: <m>0, 0.5, 1, 1.5</m>. A complete approximation will consist of the <m>y</m>-values from the following four points:   
		</p>

		<me>
			(0,\ y(0)),\quad (0.5,\ y(0.5)),\quad (1,\ y(1)),\quad (1.5,\ y(1.5)).
		</me>

		<p>
			The initial condition, <m>y(0) = -2</m>, gives us the first point and this is where Euler's Method officially begins.
		</p>

		<p>
			From our current position, <m>(0, -2)</m>, we need the direction (i.e., slope, <m>y'(0)</m>) that our solution, <m>y</m>, moves along at <m>t=0</m>. Notice that the differential equation is basically machine that outputs <m>y'(t)</m> values for any <m>t</m>. In particular, for <m>t = 0</m> we get
		</p>

		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=0}{\quad\longrightarrow\quad} 
			y'(0) = 6(0) + y(0) 
			\quad\longrightarrow\quad
			y'(0) = -2.
		</me>

		<p>
			This slope says that when <m>t</m> increases by <m>1</m>, <m>y</m> changes by <m>-2</m>. But, you can also say that when <m>t</m> increases by <m>h</m>, <m>y</m> changes by <m>-2\cdot h</m> since both lead to the same slope:
		</p>

		<me>
			\text{slope}\ = -2:\quad
			-\frac{2}{1}\
			\left(\frac{\text{down}\ 2}{\text{right}\ 1}\right)
			\ \ \text{and}\ \
			-\frac{2\cdot h}{1\cdot h}\
			\left(\frac{\text{down}\ 2h}{\text{right}\ h}\right)
		</me>

		<p>
			Thus, from <m>(0, -2)</m>, <m>t</m> moves right by <m>0.5</m> and <m>y</m> moves down by <m>-2\cdot 0.5 = -1</m>, giving the next approximation as <m>y(0.5) \approx -3</m> and the new position <m>(0.5, -3)</m>.
		</p>

		<p>
			Now, we repeat the process. From our new position, <m>(0.5, -3)</m>, we need the slope at <m>t = 0.5</m>, which comes directly from the differential equation:
		</p>

		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=0.5}{\quad\longrightarrow\quad} 
			y'(0.5) = 6(0.5) + y(0.5) 
			\quad\longrightarrow\quad
			y'(0.5) = 0.
		</me>

		<p>
			A zero slope says that <m>y</m> does not change at all. So, <m>y(1) \approx -3</m> and the new position is <m>(1, -3)</m>.
		</p>

		<p>
			Finally, <m>(1, -3)</m>, we compute the slope at <m>t = 1</m>:
		</p>
		<me>
			y'(t) = 6t + y(t) 
			\os{\large t=1}{\quad\longrightarrow\quad} 
			y'(1) = 6(1) + y(1) 
			\quad\longrightarrow\quad
			y'(1) = 3.
		</me>

		<p>
			Here, when <m>t</m> increases by <m>0.5</m>, <m>y</m> moves up by <m>3\cdot 0.5 = 1.5</m>. So the last value is <m>y(1.5) \approx -1.5</m> and the complete approximation is given by the values:
		</p>

		<sidebyside widths="6% 38% 50% 6%" valign="middle">
			<p/>
			<p>
				<md>
					<mrow> y(0)		\amp \approx -2.0,</mrow>
					<mrow> y(0.5)	\amp \approx -3.0,</mrow>
					<mrow> y(1)		\amp \approx -3.0,</mrow>
					<mrow> y(1.5)	\amp \approx -1.5.</mrow>
				</md>
			</p>
			<p>
				<image>
					<latex-image>
							\begin{tikzpicture}[samples=50]
		
								% === colors ===
								\def\fColor{blue}			\def\fFill{\fColor!15}
								\def\gColor{green!60!black}	\def\gFill{\gColor!15}

								% === figure/domain/tick bounds ===
								\def\tmin{-0.2}	\def\tmax{1.8}
								\def\ymin{-4.9}	\def\ymax{1.8}
								\def\tticks{1, 2}
								\def\yticks{2, 4}
								\def\dyA{-2} \def\dyB{0} \def\dyC{3}
								\def\h{0.5} \def\s{0.5}


								% === Function definitions ===
								\newcommand{\f}[1]{e^(#1)}	\def\ftex{e^t}
								\def\ta{0}	\def\b{2}
								\def\c{1.13}

								\begin{axis}[
									width=24cm, height=8cm, scale=0.25,
									xlabel={$t$}, ylabel={$y$},
									%title={Euler's Method Step 1},
									title style={font=\small},
									grid=both,
									%tick style={thick},
									line width=1pt,
									axis lines=middle,
									xtick distance=0.5, ytick distance=2,
									minor x tick num=0, minor y tick num=1,
									xmin=\tmin, xmax=\tmax, ymin=\ymin, ymax=\ymax,
									xticklabel style={yshift=1.5em, font=\scriptsize},
									yticklabel style={font=\scriptsize},
								]
								
									% Read and plot data from file
									\addplot+ [only marks] coordinates {
										(0.0,-2.0)
										(0.5,-3.0)
										(1.0,-3.0)
										(1.5,-1.5)
									};
									\addplot+ [black, no marks, -&gt;] (0.0, -2.0) -- ({0.0+\h*\s}, {-2.0+\dyA*\h*\s});
									\addplot+ [black, no marks, -&gt;] (0.5, -3.0) -- ({0.5+\h*\s}, {-3.0+\dyB*\h*\s});
									\addplot+ [black, no marks, -&gt;] (1.0, -3.0) -- ({1.0+\h*\s}, {-3.0+\dyC*\h*\s});

									\node[font=\scriptsize] at (0.22,	-4.3)	{slope: $-2$};
									\node[font=\scriptsize] at (0.68,	-4.3)	{slope: $0$};
									\node[font=\scriptsize] at (1.18,	-4.3)	{slope: $3$};
								\end{axis}
							\end{tikzpicture}
					</latex-image>
				</image>
			</p>
			<p/>
		</sidebyside>
	</paragraphs>

	<paragraphs><title> How Euler's Method Works </title>

		<p>
			Euler’s Method is a step-by-step process for approximating the solution to a differential equation of the form
		</p>

		<me>
			y'(t) = f(t, y), \quad y(t_0) = y_0, \quad \text{for } t \text{ in } [t_0, t_N].
		</me>

		<p>
			The goal is to estimate the values of the solution <m>y(t)</m> at a sequence of evenly spaced time points:
		</p>

		<me>
			t_0,\ t_1,\ t_2,\ \ldots,\ t_N,
		</me>

		<p>
			where each is separated by the step size, <m>h</m> (i.e., <m>t_{k+1} = t_k + h</m>). For convenience, we'll use the shorthand <m>y_k = y(t_k)</m>, so the solution points we want to approximate are:
		</p>

		<me>
			(t_0, y_0),\ (t_1, y_1),\ (t_2, y_2),\ \ldots,\ (t_N, y_N).
		</me>

		<p>
			Since the initial condition <m>y(t_0) = y_0</m> is given, we know the first point, <m>(t_0, y_0)</m>. So it makes sense to always start here.
			
			
			The remaining points are approximated using the differential equation itself, which provides the slope of the solution at each point.
			At each step, you know your current position <m>(t_k, y_k)</m>, and the differential equation tells you the direction to move to get the next position. But, how do you use this information to get to the next position <m>(t_{k+1}, y_{k+1})</m>?
		</p>

	</paragraphs>

	<paragraphs><title> Euler's Method Process </title>

	</paragraphs>

	<paragraphs><title> Step 1: Set-up &amp; Verify </title>

		<outcomes>
			<ul>
				<li>
					
				</li>
				<li>
					
				</li>
				<li>
					Master <xref text="custom" ref="euler-step1"> Step 1 </xref> of <xref ref="euler-method" text="title"/>
				</li>
			</ul>
		</outcomes>

		<p>
			Euler's method operates on a very intuitive principle: starting from an initial point, the method uses the differential equation itself to take small steps along the direction of the slope given by the equation. At each step, the method calculates the slope of the unknown function at the current point, then moves a small distance in the direction of this slope to find the next point. By repeating this process, Euler's method generates a sequence of points that approximates the true solution curve of the differential equation.
		</p>

	</paragraphs>

	<paragraphs><title> Step 2: Find <m>y_{n+1}</m> </title>

		<outcomes>
			<ul>
				<li>
					.
				</li>
				<li>
					Master <xref text="custom" ref="euler-step2"> Step 2 </xref> of <xref ref="euler-method" text="title"/>
				</li>
			</ul>
		</outcomes>

		<p>
			Suppose we want to find an approximate solution to the differential equation
			<me>
				y' = x + y, \quad y(0) = -\frac{7}{8}.
			</me>
			
		</p>
		
		<image xml:id="sageplot-polynomial-approximation">

			<sageplot variant="2d">
				y = lambda x : (1/8)*exp(x)-x-1
				euler = lambda x, y, dx : y + dx*(x + y)
				y0 = -7/8
				x0, h, xF = 0, 0.5, 1.5
				ymin, ymax = -3, 1

				y_data = [(x0, y0)]
				yp = y0

				for xp in xsrange(x0, xF, h):
					yp = euler(xp, yp, h)
					y_data.append((xp + h, yp))

				xticks = [0, 0.5, 1, 1.5, 2]
				yticks = [i for i in range(ymin, ymax)]

				grid_rgbcolor = (0.9, 0.9, 0.9)
				grid = plot([], ymin=ymin, ymax=ymax, fontsize=16, ticks=[xticks, yticks],)
				

				for gx in xsrange(x0, xF, 0.25, include_endpoint=True):
					grid += line([(gx, ymin),(gx, ymax)], rgbcolor=grid_rgbcolor)
				for gy in xsrange(ymin, ymax, 1, include_endpoint=True):
					grid += line([(x0,  gy),(xF, gy)], rgbcolor=grid_rgbcolor)

				y_plot = plot(y, x0, xF, rgbcolor='red', thickness=1,)
				yn_plot = list_plot(y_data,  markeredgecolor="black", rgbcolor=(0.2,0.8,0.1), pointsize=40)
				y_plot + yn_plot + grid

			</sageplot>
		</image>

		<image xml:id="euler-idea-plot" width="60%">
			<sageplot>
				U = plot(0, (x, -2, -0.1), color='blue', thickness=4, ymin=-1, ymax=1.5, fontsize=20, ticks=[1,1])
				U += plot(1, (x, 0, 5), color='blue', thickness=4, ymin=-1, ymax=1.5, fontsize=20, ticks=[1,1])
				U += point([0,0], color = "blue", faceted=True, size = 80)
				U += point([0,0], color = "white", faceted=True, size = 15)
				U += point([0,1], color = "blue", faceted=True, size = 80)
				U
			</sageplot>

		</image>


		<example xml:id="euler-example-01">

			<statement>
				<p>
					Approximate the solution to the differential equation
					<me> y' = y^2 - x, \quad y(0) = -1 </me>
					over the interval <m>[0, 1]</m> with a step size of <m>h = 0.5</m>.
				</p>
			</statement>

			<solution>
				<p>
					fd
				</p>
			</solution>

		</example>

		<image width="100%">
			<latex-image>
				% User Defined Parameters
				\def\a{0} 		% interval start
				\def\b{1} 		% interval end
				\def\h{0.2} 	% stepsize
				\def\round{2}	% decimal rounding
				\def\s{5}  		% scaling factor

				\begin{tikzpicture}[scale=\s]

					\pgfkeys{/pgf/number format/.cd,fixed,precision=\round}
				
					% Calculate number of partitions
					\pgfmathsetmacro{\N}{(\b-\a)/\h}
					
					% Draw the x-axis
					\draw[-&gt;,thick] (\a - 2*\h/\s,0) -- (\b + 2*\h/\s,0) node[right] {$x$};

					% Draw the partition points and labels
					\foreach \i in {0,...,\N}
					{
						\pgfmathsetmacro{\currentPoint}{\a + \i*\h}
						\draw (\currentPoint,0.1/\s) -- (\currentPoint,-0.1/\s) node[below] {$\pgfmathprintnumber{\currentPoint}$};
						\draw 							(\currentPoint,-0.5/\s) node[below] {$x_{\i}$};

					}
					
				\end{tikzpicture}
			</latex-image>
		</image>

		<p>
			<md>
				<mrow> y'(x_i) 										\amp = (y(x_i))^2 - x_i </mrow>
				<mrow> \frac{y(x_{i+1}) - y(x_i)}{h}	\amp = (y(x_i))^2 - x_i </mrow>
				<mrow> \frac{y_{i+1} - y_i}{h}	\amp = (y_i)^2 - x_i </mrow>
				<mrow> y(x_{i+1}) - y(x_i) 							\amp = h\left((y(x_i))^2 - x_i\right) </mrow>
				<mrow> y(x_{i+1}) 									\amp = y(x_i) + h\left((y(x_i))^2 - x_i\right) </mrow>
			</md>
		</p>

	</paragraphs>

	<paragraphs><title> Step 3: Get Approximation </title>
		
		<outcomes>
			<ul>
				<li>
					
				</li>
				<li>
					Master <xref text="custom" ref="euler-step3"> Step 3 </xref> of <xref ref="euler-method" text="title"/>
				</li>
			</ul>
		</outcomes>

		<p>
			Write this section.
		</p>

	</paragraphs>

	<paragraphs><title> Plotting a Line with a Point and the Slope </title>
		<p>
			Suppose you have a line in slope-intercrpt form, <m>y = mx+b</m>. Recall that the fractional form of the slope, <m>m</m>, was often interpreted as the <q>rise</q> over the <q>run</q>, meaning you can get from one point to another by moving up (if the slope is positive) by the <q>rise</q> and left by the <q>run</q>.
		</p>

		<p>
			For example, a line in the form
		</p>

		<me>
			y = \frac32 x - 1
		</me>
		
		<p>
			has a <m>y</m>-intercept of <m>-1</m>, which means it passes through <m>(0,-1)</m>. The slope, <m>\frac32</m>, indicates a rise of <m>3</m> and a run of <m>2</m>, so we get to the point <m>(2,2)</m> from the point <m>(0,-1)</m> by moving up <m>3</m> and right <m>2</m> as shown in <xref ref="rise-3-run-2"/>.
		</p>

		<p>
			In this example, the rise and run were simply the numerator and denominator. However, a different rise and run value could come from multiplying the numerator and denominator by any non-zero number. For example, all of the following are the same slope with a different rise and run:  
		</p>

		<me>
			\frac{\text{rise}}{\text{run}}\quad\rightarrow\quad \frac32 = \frac{6}{4} = \frac{3\pi}{2\pi} = \frac{\frac32}{1} = \frac{\frac32h}{h} =\ \ldots.
		</me>

		<p>
			as illustrated in <xref ref="one-slope-multiple-rise-run"/>.
		</p>

		<figure xml:id="one-slope-multiple-rise-run"><caption>Same Slope, Different Rise and Runs</caption>
			<sidebyside widths="7.6% 23.4% 6% 25% 6% 24.6% 7.4%" valign="top">
				<p/>
				<figure xml:id="rise-3-run-2"><caption>Rise <m>3</m>, run <m>2</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{2} \def\rise{3} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}						% point coordinates
							\def\tmin{-0.8} \def\tmax{3.9}
							\def\ymin{-0.8} \def\ymax{4.8}
							\def\tticks{1,3} \def\yticks{1,4}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,4}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.6]
								
								% === t-axis and grid ===
								\foreach \tk in \tgrid{\draw[thin, gray!50!white] (\tk,\ymin) -- (\tk,\ymax);}
								\foreach \tk in \tticks{
									\draw (\tk,-0.1) -- (\tk,0.1)
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway, font=\small] {$\tk$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \yk in \ygrid{\draw[thin, gray!50!white] (\tmin,\yk) -- (\tmax,\yk);}
								\foreach \yk in \yticks{
									\draw (-0.1,\yk) -- (0.1,\yk)
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway, font=\small] {$\yk$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.2, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=0cm, inner sep = 1pt, midway, font=\small] {$\rise$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$\run$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.06cm, font=\small] {$(\ta,\ya)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.3cm, yshift=-0.15cm, font=\small] {$(3,4)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>
				<p/>
				<figure xml:id="rise-1pt5-run-1"><caption>Rise <m>\frac32</m>, run <m>1</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{1} \def\rise{1.5} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}					% point coordinates
							\def\tmin{-0.8} \def\tmax{3.4}
							\def\ymin{-0.8} \def\ymax{3.9}
							\def\tticks{1,2,3} \def\yticks{1,2,3}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,3}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.7]
								
								% === t-axis and grid ===
								\foreach \tk in \tgrid{\draw[thin, gray!50!white] (\tk,\ymin) -- (\tk,\ymax);}
								\foreach \tk in \tticks{
									\draw (\tk,-0.1) -- (\tk,0.1)
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway, font=\small] {$\tk$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \yk in \ygrid{\draw[thin, gray!50!white] (\tmin,\yk) -- (\tmax,\yk);}
								\foreach \yk in \yticks{
									\draw (-0.1,\yk) -- (0.1,\yk)
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway, font=\small] {$\yk$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.4, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=-0.1cm, inner sep = 1pt, midway, font=\small] {$\sfrac32$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$\run$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.06cm, font=\small] {$(\ta,\ya)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.1cm, font=\small] {$(2,\frac52)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>	
				<p/>
				<figure xml:id="rise-mh-run-h"><caption>Rise <m>mh</m>, run <m>h</m></caption>
					<image>
						<latex-image>
							% === User Defined Parameters ===
							\def\run{2} \def\rise{3} \def\yint{-0.5}	% slope rise/run, yintercept
							\def\ta{1} \def\ya{1}						% point coordinates
							\def\tmin{-0.8} \def\tmax{4.3}
							\def\ymin{-0.8} \def\ymax{4.8}
							\def\tticks{1,3} \def\yticks{1,4}
							\def\tgrid{1,2,...,3} \def\ygrid{1,2,...,4}
							\def\steps{1} \pgfmathsetmacro\N{\steps - 1}
							
							\begin{tikzpicture}[scale=0.6]
								
								% === t-axis and grid ===
								\foreach \k in {0,1}{
									\draw[thin, gray!50!white] ({\ta + \k*\run},\ymin) -- ({\ta + \k*\run},\ymax);
									\draw[black] ({\ta + \k*\run},-0.1) -- ({\ta + \k*\run},0.1) 
									node[fill=white, inner sep = 1pt, yshift=-0.1cm, below, midway] {$t_{\k}$};
								}
								\draw[black, -&gt;] (\tmin, 0) -- (\tmax, 0) node[below] {$t$};
								
								% === y-axis and grid ===
								\foreach \k in {0,1}{
									\draw[thin, gray!50!white] (\tmin, {\ya + \k*\rise}) -- (\tmax, {\ya + \k*\rise});
									\draw (-0.1, {\ya + \k*\rise}) -- (0.1, {\ya + \k*\rise})
									node[fill=white, inner sep = 1pt, xshift=-0.1cm, left, midway] {$y_{\k}$};
								}
								\draw[-&gt;] (0, \ymin) -- (0, \ymax) node[right] {$y$};
								
								% === line plot ===
								\draw[ultra thick, domain=\tmin+0.5:\tmax-0.5, &lt;-&gt;] plot[] (\x, \rise/\run*\x + \yint);

								% === rise/run display ===
								\foreach \k in {0,...,\N}
								{
									\pgfmathsetmacro{\tk}{\ta + \k*\run}
									\pgfmathsetmacro{\yk}{\ya + \k*\rise}
									\draw[blue!80!green, very thick, -&gt;]
										(\tk, \yk) -- (\tk, \yk + \rise)
										node[fill=white, xshift=0cm, inner sep = 1pt, midway, font=\small] {$\frac32h$};
									\draw[blue!40!green, very thick, -&gt;]
										(\tk, \yk + \rise) -- (\tk + \run - 0.1, \yk + \rise)
										node[fill=white, inner sep = 0pt, xshift=0cm, midway, font=\small] {$h$};
									\draw[fill=white, very thick] (\tk, \yk) circle (3pt);
								}

								% === first point label ===
								\draw (\ta, \ya) node[below, fill=white, inner sep = 1pt, xshift=0.55cm, yshift=-0.1cm, font=\small] {$(t_0,y_0)$};

								% === second point label ===
								\pgfmathsetmacro{\tk}{\ta + \run}
								\pgfmathsetmacro{\yk}{\ya + \rise}
								\draw (\tk, \yk) node[below, fill=white, inner sep = 1pt, xshift=0.4cm, yshift=-0.2cm, font=\small] {$(t_1,y_1)$};

								% === last point ===
								\pgfmathsetmacro{\tk}{\ta + \steps*\run}
								\pgfmathsetmacro{\yk}{\ya + \steps*\rise}
								\draw[fill=white, very thick] (\tk, \yk) circle (3pt);

							\end{tikzpicture}
						</latex-image>
					</image>
				</figure>
				<p/>
			</sidebyside>
		</figure>

		<p>
			In general, if <m>m</m> is the slope, then we also have
		</p>

		<me>
			\frac{\text{rise}}{\text{run}}\quad\rightarrow\quad m = \frac{m}{1} = \frac{m\cdot h}{1\cdot h} = \frac{mh}{h},
		</me>

		<p>
			where the last expression has a rise of <m>mh</m> and a run of <m>h</m>. This shows that a run of <m>h</m> to the next point must be paired with a rise of <m>mh</m>. In particular, 
		</p>

		<me>
			\text{A run of}\ h\ \text{from}\ (t_0, y_0)\ \text{leads to}\ (t_1, y_1) = (t_0 + h, y_0 + mh),
		</me>

	</paragraphs>

	<paragraphs><title> Euler's Method </title>

		<objectives>
			<introduction>
				<p>
					After this chapter, you will be able to ...
				</p>
			</introduction>
			<ol>
				<li>  </li>
				<li>  </li>
				<li>  </li>
			</ol>
		</objectives>

		<p>
			In the context of Euler's method, the slope at <m>t=0</m> is
		</p>

		<me>
			\text{slope:}\ y'(0) = \frac{y'(0)}{1} = \frac{y'(0)\cdot h}{1\cdot h}.
		</me>

		<p>
			This implies that for a run of <m>h</m>, the rise is <m>y'(0)\cdot h</m>. This is exactly how Euler's method goes from the initial condition <m>(0, y(0))</m> to the next point in the approximation.
		</p>

		<me>
			y_{i+1} = y_i + hy_i'
		</me>

		<sidebyside widths="6% 38% 50% 6%" valign="middle">
			<p/>
			<p>
				<md>
					<mrow> \text{slope:} \amp y_k' = \frac{y_k'}{1} = \frac{y_k'\cdot h}{1\cdot h} </mrow>
				</md>
			</p>
			<p>
				<image>
					<latex-image>
						\begin{tikzpicture}[samples=50]
	
							% === colors ===
							\def\fColor{blue}			\def\fFill{\fColor!15}
							\def\gColor{green!60!black}	\def\gFill{\gColor!15}

							% === figure/domain/tick bounds ===
							\def\tmin{-0.8}	\def\tmax{6}
							\def\ymin{-0.6}	\def\ymax{3.5}
							\def\tA{2.0}	\def\ytA{1}	
							\def\tB{4.0}	\def\ytB{2.5}
							\def\h{2}

							\begin{axis}[
								width=10cm, height=6cm, scale=0.7,
								xlabel={$t$}, ylabel={$y$},
								%title={Euler's Method Step 1},
								title style={font=\small},
								grid=both,
								line width=1pt,
								axis lines=middle,
								%xtick distance=2, 
								%ytick distance=1,
								%minor x tick num=0,
								%minor y tick num=0,
								xmin=\tmin, xmax=\tmax, 
								ymin=\ymin, ymax=\ymax,
								xticklabel style={yshift=0.0em, font=\normalsize, fill=white},
								yticklabel style={xshift=0.1em, font=\normalsize, fill=white},
								xtick={\tA, \tB},	xticklabels={$t_{k}$, $t_{k+1}$},
								ytick={\ytA, \ytB},	yticklabels={$y_{k}$, $y_{k+1}$},
							]
							
								% Read and plot data from file
								\addplot+ [only marks] coordinates {
									(\tA, \ytA)
									(\tB, \ytB)
								};
								\addplot+ [gray, no marks, -&gt;] (\tA, \ytA) -- (\tA, \ytB) node[fill=white, left, midway] {$h\cdot y_k'$};
								\addplot+ [gray, fill=white, no marks, -&gt;] (\tA, \ytB) -- ({\tB - 0.1}, \ytB) node[fill=white, midway] {$h$};
								
								\draw [&lt;-&gt;] (axis cs: \tB, 0) -- (axis cs: \tB, \ytA) node[midway, right, fill=white] {$y_k$};
								\draw [&lt;-&gt;] (axis cs: \tB, \ytA) -- (axis cs: \tB, {\ytB - 0.1}) node[midway, right, fill=white] {$h\cdot y_k'$};
								\node[font=\small, gray, rotate=90] at (axis cs: {\tA - 1.5}, {0.5*(\ytA + \ytB)}){rise};
								\node[font=\small, gray] at (axis cs: {0.5*(\tA + \tB)}, {\ytB + 0.5}){run};
								\node[font=\small, below] at (axis cs: {\tA + 0.55}, \ytA){$(t_k,y_k)$};
								\node[font=\small, above] at (axis cs: {\tB + 0.85}, \ytB){$(t_{k+1},y_{k+1})$};
							\end{axis}
						\end{tikzpicture}
					</latex-image>
				</image>
			</p>
			<p/>
		</sidebyside>

		<p>
			Euler's method operates on a very intuitive principle: starting from an initial point, the method uses the differential equation itself to take small steps along the direction of the slope given by the equation. At each step, the method calculates the slope of the unknown function at the current point, then moves a small distance in the direction of this slope to find the next point. By repeating this process, Euler's method generates a sequence of points that approximates the true solution curve of the differential equation.
		</p>
	
		<exploration xml:id="euler-method"><title> Euler's Method </title>
			<p>
				An approximate solution to the first order differential equation
				<men xml:id="euler-method-de">
					y' = f(x, y), \quad y(a) = y_0
				</men>
				can be found on the interval <m>[a, b]</m> through the following steps...
			</p>
			<dl width="narrow">
				<li xml:id="euler-step1"><title> Step 1: Set-up </title>
					<p>
						<line>Choose <m>h</m>.</line>
						<line>Break <m>[a, b]</m> into
						<m>
							x_0,\ x_1,\ x_2,\ ...,\ x_{N-1},\ x_{N},
						</m>
						separated by <m>h</m>.
						</line>
					</p>
				</li>
				<li xml:id="euler-step2"><title> Step 2: Find Approximation Formula <m>y_{i+1}</m> </title>
					<p>
						<line>Substitute <m>x_i</m> into <xref ref="euler-method-de"/> &amp; rewrite <m>y(x_i)</m> as <m>y_i</m> and <m>y^\prime(x_i)</m> as <m>y^\prime_i</m>.</line>
						<line>Replace <m>y^\prime_i</m> with <m>\ds\frac{1}{h}(y_{i+1} - y_{i})</m>.</line>
						<line>Isolate <m>y_{i+1}</m>.</line>
					</p>
				</li>
				<li xml:id="euler-step3"><title> Step 3: Compute Approximation Values </title>
					<p>
						<line>Find <m>y_1, y_2, ... , y_N</m> using the approximation formula.</line>
					</p>
				</li>
			</dl>
		</exploration>
		
		<p>
			Use Euler's Method to approximate the solution to the initial-value problem,

			<mdn>
				<mrow xml:id="euler-ex-01-de">	y'(x) - 2xy(x) = 0	\amp </mrow>
				<mrow xml:id="euler-ex-01-ic">	y(0) = 2, \amp </mrow>
			</mdn>
			at the <m>x</m>-values <m>0,\ 0.5,\ 1,\ 1.5,\ 2 \ </m>(spaced 0.5 apart).
		</p>

		<p>
			Euler's method works by replacing <m>y'(x)</m> in <xref ref="euler-ex-01-de"/> with it's forward-difference approximation, giving us
			<me>
				\frac{1}{h}\Big(y(x+h) - y(x)\Big) - 2 xy(x) = 0
			</me>
			and if we let <m>h</m> be the space between the <m>x</m>-values (0.5), then we have
			<me>
				\frac{1}{0.5}\Big(y(x+0.5) - y(x)\Big) - 2 xy(x) = 0.
			</me>
		</p>

		<p>
			To see how this is helpful, we isolate <m>y'(x+h)</m> as follows
			<md>
				<mrow>	\frac{1}{0.5}\Big(y(x+0.5) - y(x)\Big) 	=\ \amp 2 xy(x)	</mrow>
				<mrow>							y(x+0.5) - y(x)	=\ \amp xy(x)	</mrow>
			</md>
			and the final step gives the approximation formula
			<men xml:id="euler-ex-01-approx">
				y(x+0.5) = y(x) + xy(x).
			</men>
		</p>

		<p>
			Note that we already know <m>y(0) = 2</m> from <xref ref="euler-ex-01-ic"/>, so to find the rest of the approximation points, we plug <m>x = 0, 0.5, 1, 1.5</m> into <xref ref="euler-ex-01-approx"/>, as shown below.
		</p>

		<p>
			<tabular top="major" valign="top">
				<col width="0%" />
				<col width="45%" />
				<col width="20%" />
				<row bottom="minor">
					<cell> <m>x</m> </cell>
					<cell halign="center"> Approximation Formula <xref ref="euler-ex-01-approx"/> </cell>
					<cell> Approximation </cell>
				</row>
				<row bottom="minor">
					<cell> <m>0</m> </cell>
					<cell halign="left">
						<line><m>y(0+0.5) = y(0) + (0)y(0)</m></line>
						<line><m>\phantom{y(0+0.5)} = 2 + (0)(2) </m></line>
						<line><m>\phantom{y(0+0.5)} = 2 </m></line>
					</cell>
					<cell> <m>y(0.5) = 2</m> </cell>
				</row>

				<row bottom="minor">
					<cell> <m>0.5</m> </cell>
					<cell halign="left">
						<line><m>y(0.5+0.5) = y(0.5) + (0.5)y(0.5)</m></line>
						<line><m>\phantom{y(0.5+0.5)} = 2 + (0.5)(2) </m></line>
						<line><m>\phantom{y(0.5+0.5)} = 3 </m></line>
					</cell>
					<cell> <m>y(1) = 3</m> </cell>
				</row>

				<row bottom="minor">
					<cell> <m>1</m> </cell>
					<cell halign="left">
						<line><m>y(1+0.5) = y(1) + (1)y(1)</m></line>
						<line><m>\phantom{y(1+0.5)} = 3 + (1)(3) </m></line>
						<line><m>\phantom{y(1+0.5)} = 6 </m></line>
					</cell>
					<cell> <m>y(1.5) = 6</m> </cell>
				</row>

				<row bottom="major">
					<cell> <m>1.5</m> </cell>
					<cell halign="left">
						<line><m>y(1.5+0.5) = y(1.5) + (1.5)y(1.5)</m></line>
						<line><m>\phantom{y(1.5+0.5)} = 6 + (1.5)(6) </m></line>
						<line><m>\phantom{y(1.5+0.5)} = 15 </m></line>
					</cell>
					<cell> <m>y(2) = 15</m> </cell>
				</row>
			</tabular>

		</p>

		<corollary>
			<sidebyside width="100%" margins="0%">
				<interactive xml:id="euler-ivp-tool"
					platform="jsxgraph"
					aspect="1:1"
					dark-mode-enabled="yes"
					source="code/jsxgraph/eulers-method/euler-ivp-tool.js"
				>
					<sidebyside width="100%">
						<slate xml:id="euler-ivp-tool-plot1" surface="jsxboard" aspect="1:1" />
					</sidebyside>
					<static>
						<image source="code/jsxgraph/img-labels/t.png" width="70%"> Need to Add </image>
					</static>
				</interactive>
			</sidebyside>
		</corollary>

	</paragraphs>

	<p>
		In summary, Euler's method is a powerful tool for approximating the solutions of differential equations that are challenging or impossible to solve analytically. By understanding and applying this method, students and professionals can gain insights into the behavior of complex systems described by such equations, even in the absence of exact solutions.
	</p>

</section>